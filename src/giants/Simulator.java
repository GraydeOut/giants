package giants;

/**
 * Simulator Class		Used to create Simulator objects. Simulates queues
 * 				of customers with linked lists.
 * 
 * @author Gray English
 * @version 1.0 3/6/2022
 * @since 1.0
 */

public class Simulator {

	/**
	 * number of customers to simulate
	 * 
	 * @version 1.0 3/6/2022
	 * @since 1.0
	 */
	
	private int numCusts;
	
	/**
	 * CustomerCreator object to generate customers
	 * 
	 * @version 1.0 3/6/2022
	 * @since 1.0
	 */
	
	private CustomerCreator creator;
	
	/**
	 * totalTime elapsed during simulation of queues
	 * 
	 * @version 1.0 3/6/2022
	 * @since 1.0
	 */
	
	int totalTime;
	
	/**
	 * simulation customers
	 * 
	 * @version 1.0 3/6/2022
	 * @since 1.0
	 */
	
	private Customer customers[];
	
	/**
	 * queues for simulating
	 * 
	 * @version 1.0 3/6/2022
	 * @since 1.0
	 */
	
	private QueueLL queues[];
	
	/**
	 * initializes a Simulator object using arrival, service times and number of
	 * customers to be simulated.
	 * 
	 * @version 1.0 3/6/2022
	 * @since 1.0
	 * @param minArr	minimum interarrival time
	 * @param maxArr	maximum interarrival time
	 * @param minSer	minimum service time
	 * @param maxSer	maximum service time
	 * @param custs		number of customers
	 */
	
	public Simulator(int minArr, int maxArr, int minSer, int maxSer, int custs) {
		//initialize fields
		numCusts = custs;
		customers = new Customer[numCusts];
		totalTime = 0;
		
		//initialize creator
		creator = new CustomerCreator(minArr, maxArr, minSer, maxSer);
		
		//setup queues
		queues = new QueueLL[3];
		for (int i = 0; i < queues.length; i++) {
			queues[i] = new QueueLL();
		}
	}
	
	/**
	 * returns a Statistics object generated by simulating queues of customers
	 * 
	 * @version 1.0 3/6/2022
	 * @since 1.0
	 * @return	statistics of simulation
	 */
	
	public Statistics simulate() {
		//initializes variables
		int servedCusts = 0;
		int nextArrival = 0;
		int custCount = 0;
		int lineOpen[] = new int[3];
		
		//loops until all customers served
		while (servedCusts < numCusts) {
			
			//gets next customer
			if (nextArrival == 0 && custCount < numCusts) {
				Customer cust = creator.nextCustomer();
				nextArrival = cust.getArrival();
				cust.setArrival(totalTime);
				enqueue(cust);
				custCount++;
			}
			
			//removes customers
			for (int i = 0; i < queues.length; i++) {
				if (queues[i].isEmpty() == false) {
					if (queues[i].frontPeak() == totalTime) {
						customers[servedCusts] = queues[i].removeFront();
						servedCusts++;
					}
				}
			}
			
			//tallies how long each line is open
			for (int i = 0; i < queues.length; i++) {
				if (queues[i].isEmpty()) {
					lineOpen[i]++;
				}
			}
			
			//counts time
			totalTime++;
			nextArrival--;
		}
		
		//returns Statistics object
		totalTime--;
		Statistics stats = new Statistics(customers, lineOpen, totalTime);
		return stats;
	}
	
	/**
	 * returns the number of the first empty queue or the queue with the 
	 * smallest size
	 * 
	 * @version 1.0 3/6/2022
	 * @since 1.0
	 * @return		number of queue
	 */
	
	private int selectQueue() {
		//finds empty queu or queue with smallest size
		int minSize = Integer.MAX_VALUE;
		int queueNum = Integer.MIN_VALUE;
		for (int i = 0; i < queues.length; i++) {
			//first empty queue
			if (queues[i].isEmpty() == true) {
				return i;
			}
			
			//queue with smallest size
			if (queues[i].size() < minSize) {
				minSize = queues[i].size();
				queueNum = i;
			}
		}
		return queueNum;
	}
	
	/**
	 * adds finish time to customer based on queue they are to be added to
	 * 
	 * @version 1.0 3/6/2022
	 * @since 1.0
	 * @param queueNum		number of queue
	 * @param cust			customer to be added to queue
	 */
	
	private void addFinishTime(int queueNum, Customer cust) {
		//adds finish time to customer
		if (queues[queueNum].isEmpty() == true) {
			cust.setFinish(totalTime + cust.getServTime());
		} else {
			int finish = queues[queueNum].rearPeak();
			finish += cust.getServTime();
			cust.setFinish(finish);
		}
	}
	
	/**
	 * adds customer to the first empty or smallest queue
	 * 
	 * @version 1.0 3/6/2022
	 * @since 1.0
	 * @param cust			customer to be added to queue
	 */
	
	private void enqueue(Customer cust) {
		int queueNum = selectQueue();
		cust.setLine(queueNum);
		addFinishTime(queueNum, cust);
		queues[queueNum].add(cust);
	}
	
}
